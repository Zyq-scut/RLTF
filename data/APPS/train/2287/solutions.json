["import sys\ninput = lambda: sys.stdin.readline().rstrip()\n\nfrom collections import deque\nN = int(input())\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nY = [(-10**9, 10**9) for _ in range(N)]\nK = int(input())\nfor _ in range(K):\n    v, p = map(int, input().split())\n    Y[v-1] = (p, p)\n\nP = [-1] * N\nQ = deque([0])\nR = []\nwhile Q:\n    i = deque.popleft(Q)\n    R.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\n\ndef calc():\n    for i in R[::-1]:\n        e, o = 0, 0\n        l, r = Y[i]\n        if r != 10 ** 9:\n            if l % 2:\n                o = 1\n            else:\n                e = 1\n        for j in X[i]:\n            a, b = Y[j]\n            if b == 10**9: continue\n            if a % 2:\n                e = 1\n            else:\n                o = 1\n            l = max(l, a - 1)\n            r = min(r, b + 1)\n        if (e and o) or (l > r):\n            print(\"No\")\n            return 0\n        elif e or o:\n            Y[i] = (l, r)\n    \n    for i in R[1:]:\n        if Y[P[i]][0] - 1 >= Y[i][0]:\n            Y[i] = (Y[P[i]][0] - 1, 0)\n        else:\n            Y[i] = (Y[P[i]][0] + 1, 0)\n    \n    print(\"Yes\")\n    for i in range(N):\n        print(Y[i][0])\n\ncalc()", "class Tree():\n    def __init__(self, n, edge, indexed=1):\n        self.n = n\n        self.tree = [[] for _ in range(n)]\n        for e in edge:\n            self.tree[e[0] - indexed].append(e[1] - indexed)\n            self.tree[e[1] - indexed].append(e[0] - indexed)\n\n    def setroot(self, root):\n        self.root = root\n        self.parent = [None for _ in range(self.n)]\n        self.parent[root] = -1\n        self.depth = [None for _ in range(self.n)]\n        self.depth[root] = 0\n        self.order = []\n        self.order.append(root)\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            for adj in self.tree[node]:\n                if self.parent[adj] is None:\n                    self.parent[adj] = node\n                    self.depth[adj] = self.depth[node] + 1\n                    self.order.append(adj)\n                    stack.append(adj)\n\nINF = 10**18\n\nimport sys\ninput = sys.stdin.readline\n\nN = int(input())\nE = [tuple(map(int, input().split())) for _ in range(N - 1)]\n\nnum = [None for _ in range(N)]\n\nK = int(input())\n\nfor _ in range(K):\n    v, p = map(int, input().split())\n    num[v - 1] = p\n\ntree = Tree(N, E)\ntree.setroot(v - 1)\n\neven = []\nodd = []\n\nfor i in range(N):\n    if num[i] is not None:\n        if tree.depth[i] % 2 == 0:\n            even.append(num[i] % 2)\n        else:\n            odd.append(num[i] % 2)\n\nif not ((all(even) or not any(even)) and (all(odd) or not any(odd))):\n    print('No')\n\nelse:\n    I = [[-INF, INF] for _ in range(N)]\n    for i in range(N):\n        if num[i] is not None:\n            I[i] = [num[i], num[i]]\n    for node in tree.order[::-1]:\n        lt, rt = I[node]\n        for adj in tree.tree[node]:\n            lt = max(lt, I[adj][0] - 1)\n            rt = min(rt, I[adj][1] + 1)\n        if lt > rt:\n            print('No')\n            break\n        I[node] = [lt, rt]\n\n    else:\n        stack = [v - 1]\n        visited = [0 for _ in range(N)]\n        visited[v - 1] = 1\n        while stack:\n            node = stack.pop()\n            for adj in tree.tree[node]:\n                if visited[adj]:\n                    continue\n                visited[adj] = 1\n                if I[adj][0] <= num[node] - 1 <= I[adj][1]:\n                    num[adj] = num[node] - 1\n                elif I[adj][0] <= num[node] + 1 <= I[adj][1]:\n                    num[adj] = num[node] + 1\n                else:\n                    print('No')\n                    break\n                stack.append(adj)\n            else:\n                continue\n            break\n        else:\n            print('Yes')\n            print('\\n'.join(map(str, num)))", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\nN = int(input())\nG = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    A, B = map(int, input().split())\n    G[A].append(B)\n    G[B].append(A)\nK = int(input())\nnum = [-1] * (N+1)\nfor _ in range(K):\n    V, P = map(int, input().split())\n    num[V] = P\n\n# check parity\nstack = [1]\ndepth = [-1] * (N+1)\ndepth[1] = 0\nwhile stack:\n    v = stack.pop()\n    for c in G[v]:\n        if depth[c] == -1:\n            depth[c] = depth[v] + 1\n            stack.append(c)\nparity = [set(), set()]\nfor i in range(1, N+1):\n    if num[i] != -1:\n        parity[depth[i] % 2].add(num[i] % 2)\nif len(parity[0]) == 2 or len(parity[1]) == 2:\n    print('No')\n    return\n\nINF = 10**9\nlb = [-INF] * (N+1)\nub = [INF] * (N+1)\n\ndef dfs1(v, p):\n    for c in G[v]:\n        if c == p:\n            continue\n        dfs1(c, v)\n        lb[v] = max(lb[v], lb[c] - 1)\n        ub[v] = min(ub[v], ub[c] + 1)\n    if num[v] != -1:\n        lb[v] = ub[v] = num[v]\n\ndfs1(1, 0)\n\ndef dfs2(v, p):\n    for c in G[v]:\n        if c == p:\n            continue\n    for c in G[v]:\n        if c == p:\n            continue\n        lb[c] = max(lb[c], lb[v] - 1)\n        ub[c] = min(ub[c], ub[v] + 1)\n        dfs2(c, v)\n\ndfs2(1, 0)\n\nfor i in range(1, N+1):\n    if lb[i] > ub[i]:\n        print('No')\n        return\n\nprint('Yes')\n\ndef dfs3(v, p):\n    for c in G[v]:\n        if c == p:\n            continue\n        if lb[c] <= num[v] - 1:\n            num[c] = num[v] - 1\n        else:\n            num[c] = num[v] + 1\n        dfs3(c, v)\n\nnum[1] = lb[1]\ndfs3(1, 0)\n\nprint(*num[1:], sep='\\n')", "def N(): return int(input())\ndef NM():return map(int,input().split())\ndef L():return list(NM())\ndef LN(n):return [N() for i in range(n)]\ndef LL(n):return [L() for i in range(n)]\nn=N()\nedge=[[] for i in range(n+1)]\nfor i in range(n-1):\n    a,b=map(int,input().split())\n    edge[a].append(b)\n    edge[b].append(a)\nINF=float(\"inf\")\nma=[INF]*(n+1)\nmi=[-INF]*(n+1)\nk=N()\nvp=LL(k)\nfor v,p in vp:\n    ma[v]=p\n    mi[v]=p\n\nimport sys\nsys.setrecursionlimit(10**6)\ndef dfs(v,d,hi,lo):\n    dep[v]=d\n    ma[v]=min(ma[v],hi)\n    mi[v]=max(mi[v],lo)\n    hi=ma[v]\n    lo=mi[v]\n    for i in edge[v]:\n        if dep[i]==-1:\n            hi,lo=dfs(i,d+1,hi+1,lo-1)\n            ma[v]=min(ma[v],hi)\n            mi[v]=max(mi[v],lo)\n            hi=ma[v]\n            lo=mi[v]\n    return hi+1,lo-1\nfor i in range(2):\n    dep=[-1 for i in range(n+1)]\n    dfs(v,0,p,p)\nfor i,j in zip(mi,ma):\n    if i>j or (i-j)%2==1:\n        print(\"No\")\n        break\nelse:\n    print(\"Yes\")\n    for i in mi[1:]:\n        print(i)", "import heapq\nimport sys\ninput = sys.stdin.readline\nINF = 10 ** 18\n\n\nn = int(input())\nedges = [list(map(int, input().split())) for i in range(n - 1)]\nk = int(input())\ninfo = [list(map(int, input().split())) for i in range(k)]\n\ntree = [[] for i in range(n)]\nfor a, b in edges:\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\nans = [INF] * n\nq = []\nfor v, val in info:\n    v -= 1\n    ans[v] = val\n    heapq.heappush(q, (-val, v))\n    for nxt_v in tree[v]:\n        if ans[nxt_v] != INF and abs(ans[v] - ans[nxt_v]) != 1:\n            print(\"No\")\n            return\n\nwhile q:\n    val, v = heapq.heappop(q)\n    val = -val\n    for nxt_v in tree[v]:\n        if ans[nxt_v] == INF:\n            ans[nxt_v] = val - 1\n            heapq.heappush(q, (-(val - 1), nxt_v))\n        else:\n            if abs(ans[v] - ans[nxt_v]) != 1:\n                print(\"No\")\n                return\n\nprint(\"Yes\")\nfor val in ans:\n    print(val)", "# coding: utf-8\n# Your code here!\nimport sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\nn, = map(int,readline().split())\n\ng = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a,b = map(int,readline().split())\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n    \n\norder = []\nparent = [-1]*n\nst = [0]\nwhile st:\n    v = st.pop()\n    order.append(v)\n    for c in g[v]:\n        if parent[v] != c:\n            parent[c] = v\n            st.append(c)\n\nINF = 1<<30\nhigh = [INF]*n\nlow = [-INF]*n\nval = [INF]*n\n\nk, = map(int,readline().split())\nfor _ in range(k):\n    v,p = map(int,readline().split())\n    high[v-1] = low[v-1] = val[v-1] = p\n\nfor v in order[:0:-1]:\n    p = parent[v]\n    #elif val[v]== INF: # v\u306b\u597d\u304d\u306a\u6570\u66f8\u3051\u308b\n    h,l = high[v]+1,low[v]-1\n    \n    if h >= INF:\n        pass\n    elif high[p]>=INF:\n        high[p] = h\n        low[p] = l\n    elif (high[p]-h)&1==0: #\u5076\u5947\u4e00\u81f4\n        if h < high[p]: high[p] = h\n        if l > low[p]: low[p] = l\n        if high[p] < low[p]:\n            print(\"No\")\n            break\n    else: #\u5076\u5947\u9055\u3063\u3066\u30c0\u30e1\n        print(\"No\")\n        break\n    #print(v,val,high,low)\n    \nelse: #OK\n    print(\"Yes\")\n    for v in order:\n        if val[v] == INF:\n            val[v] = low[v]\n        for c in g[v]:\n            high[c] = min(high[c],val[v]+1)\n            low[c] = max(low[c],val[v]-1)\n    \n    \n    print(*val,sep=\"\\n\")\n\n\n\n\n\n\n", "import sys\nreadline = sys.stdin.readline   \n\ndef getpar(Edge, p):\n    N = len(Edge)\n    par = [0]*N\n    par[0] = -1\n    par[p]  -1\n    stack = [p]\n    visited = set([p])\n    while stack:\n        vn = stack.pop()\n        for vf in Edge[vn]:\n            if vf in visited:\n                continue\n            visited.add(vf)\n            par[vf] = vn\n            stack.append(vf)\n    return par\n\ndef topological_sort_tree(E, r):\n    Q = [r]\n    L = []\n    visited = set([r])\n    while Q:\n        vn = Q.pop()\n        L.append(vn)\n        for vf in E[vn]:\n            if vf not in visited:\n                visited.add(vf)\n                Q.append(vf)\n    return L\n\ndef getcld(p):\n    res = [[] for _ in range(len(p))]\n    for i, v in enumerate(p[1:], 1):\n        res[v].append(i)\n    return res\n\n\ndef check(L, Par, wri, even):\n    for i in range(len(Par)):\n        if wri[i] and (wri[i] % 2 == even[i]):\n            return False\n    \n    inf = 10**9+7\n    dpu = [w if w is not None else inf for w in wri]\n    dpd = [w if w is not None else -inf for w in wri]\n    for l in L[::-1][:-1]:\n        if dpu[l] == inf:\n            continue\n        if dpd[l] > dpu[l]:\n            return False\n        p = Par[l]\n        dpu[p] = min(dpu[p], dpu[l] + 1)\n        dpd[p] = max(dpd[p], dpd[l] - 1)\n    if dpd[root] > dpu[root]:\n        return False\n    ans = [None]*N\n    ans[root] = wri[root]\n    for l in L[1:]:\n        p = Par[l]\n        if ans[p] - 1 >= dpd[l]:\n            ans[l] = ans[p] - 1\n        else:\n            ans[l] = ans[p] + 1\n    return ans\nN = int(readline())\nEdge = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = map(int, readline().split())\n    a -= 1\n    b -= 1\n    Edge[a].append(b)\n    Edge[b].append(a)\nK = int(readline())\n\nVP = [tuple(map(lambda x: int(x), readline().split())) for _ in range(K)]\nwri = [None]*N\nfor v, p in VP:\n    wri[v-1] = p\n\nroot = VP[0][0] - 1\nPar = getpar(Edge, root)\nL = topological_sort_tree(Edge, root)\n\neven = [True]*N\neven[root] = (wri[root] %2 == 0)\nfor l in L[1:]:\n    p = Par[l]\n    even[l] = not even[p]\nans = check(L, Par, wri, even)\nif ans == False:\n    print('No')\nelse:\n    print('Yes')\n    print('\\n'.join(map(str, ans)))", "import sys\nsys.setrecursionlimit(10**7)\ndef main0(n,ab,k,vp):\n  ki=[[] for _ in range(n)]\n  for a,b in ab:\n    a,b=a-1,b-1\n    ki[a].append(b)\n    ki[b].append(a)\n  lrf=[[-1,-1,-1,] for _ in range(n)]\n  for v,p in vp:\n    v-=1\n    lrf[v]=[p,p,p%2]\n  flg=[True]\n  def func(p,v):\n    if lrf[v][2]!=-1:\n      l,r,f=lrf[v]\n      # \u89aa\u9802\u70b9\u3068\u306e\u6574\u5408\u6027\n      if p>=0:\n        pl,pr,pf=lrf[p]\n        if pl-1<=l<=pr+1 and pf^f==1:\n          # ok\n          pass\n        else:\n          flg[0]=False\n    else:\n      # \u89aa\u9802\u70b9\u304b\u3089\u6761\u4ef6\u3092\u8a08\u7b97\n      pl,pr,pf=lrf[p]\n      l,r,f=pl-1,pr+1,pf^1\n      lrf[v]=[l,r,f]\n    l,r,f=lrf[v]\n    for nv in ki[v]:\n      if nv==p:continue\n      # \u5b50\u9802\u70b9\u305f\u3061\u306e\u6761\u4ef6\u304b\u3089\u3001\u81ea\u5206\u306e\u6761\u4ef6\u3092\u66f4\u65b0\n      nl,nr,nf=func(v,nv)\n      if f^nf==0:flg[0]=False\n      l=max(l,nl-1)\n      r=min(r,nr+1)\n      if l>r:flg[0]=False\n    lrf[v]=[l,r,f]\n    # \u6700\u7d42\u7684\u306a\u81ea\u5206\u306e\u6761\u4ef6\u3092\u8fd4\u3059\n    return (l,r,f)\n  func(-1,vp[0][0]-1)\n  if not flg[0]:return []\n  ret=[0]*n\n  def func0(p,v):\n    l,r,f=lrf[v]\n    np=ret[p]\n    if l<=np-1<=r and (np-1)%2==f:\n      ret[v]=np-1\n    elif l<=np+1<=r and (np+1)%2==f:\n      ret[v]=np+1\n    else:\n      flg[0]=False\n    for nv in ki[v]:\n      if nv!=p:\n        func0(v,nv)\n  ret[vp[0][0]-1]=vp[0][1]\n  for nv in ki[vp[0][0]-1]:\n    func0(vp[0][0]-1,nv)\n  if flg[0]:return ret\n  else:return []\n\n\ndef __starting_point():\n  n=int(input())\n  ab=[list(map(int,input().split())) for _ in range(n-1)]\n  k=int(input())\n  vp=[list(map(int,input().split())) for _ in range(k)]\n  ret0=main0(n,ab,k,vp)\n  if len(ret0)==0:print('No')\n  else:\n    print('Yes')\n    for x in ret0:print(x)\n\n__starting_point()", "class Graph:\n    def __init__(self, n_vertices, edges, directed=True):\n        self.n_vertices = n_vertices\n        self.directed = directed\n        self.edges = edges\n\n    @property\n    def adj(self):\n        try:\n            return self._adj\n        except AttributeError:\n            adj = [[] for _ in range(self.n_vertices)]\n            if self.directed:\n                for u,v in self.edges:\n                    adj[u].append(v)\n            else:\n                for u,v in self.edges:\n                    adj[u].append(v)\n                    adj[v].append(u)\n            self._adj = adj\n            return adj\n\n\ndef solve(tree, vp):\n\n    adj = tree.adj\n    n = tree.n_vertices\n    q = [v-1 for v,p in vp]\n    ranges = [None]*n\n    for v,p in vp:\n        ranges[v-1] = (p,p)\n    \n    while q:\n        nq = []\n        for v in q:\n            a,b = ranges[v]\n            na,nb = a-1,b+1\n            for u in adj[v]:\n                if ranges[u] is None:\n                    ranges[u] = na,nb\n                    nq.append(u)\n                else:\n                    c,d = ranges[u]\n                    if (c+na)%2 == 1:\n                        return None\n                    x,y = max(na,c),min(nb,d)\n                    if x > y:\n                        return None\n                    ranges[u] = (x,y)\n                    if (x,y) != (c,d):\n                        nq.append(u)\n        q = nq\n    return [a for a,b in ranges]\n\n\ndef __starting_point():\n    n = int(input())\n    edges = [tuple(map(lambda x:int(x)-1,input().split())) for _ in range(n-1)]\n    k = int(input())\n    vp = [tuple(map(int,input().split())) for _ in range(k)]\n\n    tree = Graph(n, edges, False)\n\n    res = solve(tree, vp)\n    if res is None:\n        print('No')\n    else:\n        print('Yes')\n        print(*res,sep='\\n')\n__starting_point()", "import sys\nsys.setrecursionlimit(500000)\n\nN = int(input())\nE = [[] for _ in range(N+1)]\nfor _ in range(N-1):\n    a, b = list(map(int, input().split()))\n    E[a].append(b)\n    E[b].append(a)\nK = int(input())\nL = [-float(\"inf\")] * (N+1)\nR = [float(\"inf\")] * (N+1)\nfor _ in range(K):\n    v, p = list(map(int, input().split()))\n    L[v] = p\n    R[v] = p\n\ntour = []\ndef dfs(v, p):\n    tour.append(v)\n    for u in E[v]:\n        if u!=p:\n            dfs(u, v)\n            tour.append(v)\ndfs(v, 0)\n\nl, r = L[v], R[v]\nodd = p % 2\nfor v in tour[1:]:\n    l -= 1\n    r += 1\n    odd = 1 - odd\n    l_, r_ = L[v], R[v]\n    if r_ != float(\"inf\") and r_%2 != odd:\n        print(\"No\")\n        return\n    l = max(l, l_)\n    r = min(r, r_)\n    L[v] = l\n    R[v] = r\nfor v in tour[-2::-1]:\n    l -= 1\n    r += 1\n    odd = 1 - odd\n    l_, r_ = L[v], R[v]\n    l = max(l, l_)\n    r = min(r, r_)\n    if l > r:\n        print(\"No\")\n        return\n    L[v] = l\n    R[v] = r\nAns = [-1] * (N+1)\nprint(\"Yes\")\nprint((\"\\n\".join(map(str, L[1:]))))\n"]